import 'tool_definition.dart';
import 'command_definition.dart';

/// Generates shell completion scripts from tool definitions.
///
/// Supports bash, zsh, and fish shells.
class CompletionGenerator {
  /// Generate bash completion script.
  static String generateBash(ToolDefinition tool) {
    final buf = StringBuffer();
    final name = tool.name;

    buf.writeln('# Bash completion for $name');
    buf.writeln('# Generated by tom_build_base v2');
    buf.writeln('');

    // Main completion function
    buf.writeln('_${name}_completions() {');
    buf.writeln('  local cur prev words cword');
    buf.writeln('  _init_completion || return');
    buf.writeln('');
    buf.writeln('  # Commands');
    buf.writeln('  local commands="${_getCommandsStr(tool)}"');
    buf.writeln('');
    buf.writeln('  # Global options');
    buf.writeln('  local global_opts="${_getGlobalOptsStr(tool)}"');
    buf.writeln('');

    // Check current context
    buf.writeln('  # Check if we\'re completing after a command');
    buf.writeln('  local in_command=""');
    buf.writeln('  for word in "\${words[@]}"; do');
    buf.writeln('    case "\$word" in');
    for (final cmd in tool.commands) {
      buf.writeln('      :${cmd.name}) in_command="${cmd.name}" ;;');
      for (final alias in cmd.aliases) {
        buf.writeln('      :$alias) in_command="${cmd.name}" ;;');
      }
    }
    buf.writeln('    esac');
    buf.writeln('  done');
    buf.writeln('');

    // Complete based on context
    buf.writeln('  if [[ -z "\$in_command" ]]; then');
    buf.writeln('    # Complete commands and global options');
    buf.writeln('    if [[ "\$cur" == :* ]]; then');
    buf.writeln('      COMPREPLY=( \$(compgen -W "\$commands" -- "\$cur") )');
    buf.writeln('    elif [[ "\$cur" == -* ]]; then');
    buf.writeln(
      '      COMPREPLY=( \$(compgen -W "\$global_opts" -- "\$cur") )',
    );
    buf.writeln('    else');
    buf.writeln(
      '      COMPREPLY=( \$(compgen -W "\$commands \$global_opts" -- "\$cur") )',
    );
    buf.writeln('    fi');
    buf.writeln('  else');
    buf.writeln('    # Complete command-specific options');
    buf.writeln('    case "\$in_command" in');

    for (final cmd in tool.commands) {
      final opts = _getCommandOptsStr(cmd);
      buf.writeln('      ${cmd.name})');
      buf.writeln('        COMPREPLY=( \$(compgen -W "$opts" -- "\$cur") )');
      buf.writeln('        ;;');
    }

    buf.writeln('    esac');
    buf.writeln('  fi');
    buf.writeln('}');
    buf.writeln('');

    // Register completion
    buf.writeln('complete -F _${name}_completions $name');

    return buf.toString();
  }

  /// Generate zsh completion script.
  static String generateZsh(ToolDefinition tool) {
    final buf = StringBuffer();
    final name = tool.name;

    buf.writeln('#compdef $name');
    buf.writeln('');
    buf.writeln('# Zsh completion for $name');
    buf.writeln('# Generated by tom_build_base v2');
    buf.writeln('');

    // Define commands
    buf.writeln('local -a commands');
    buf.writeln('commands=(');
    for (final cmd in tool.commands) {
      final desc = cmd.description.replaceAll("'", "\\'");
      buf.writeln("  ':${cmd.name}:$desc'");
    }
    buf.writeln(')');
    buf.writeln('');

    // Define global options
    buf.writeln('local -a global_opts');
    buf.writeln('global_opts=(');
    for (final opt in tool.allGlobalOptions) {
      final desc = opt.description.replaceAll("'", "\\'");
      if (opt.abbr != null) {
        buf.writeln("  '-${opt.abbr}[$desc]'");
      }
      buf.writeln("  '--${opt.name}[$desc]'");
    }
    buf.writeln(')');
    buf.writeln('');

    // Main completion function
    buf.writeln('_$name() {');
    buf.writeln('  local curcontext="\$curcontext" state line');
    buf.writeln('  typeset -A opt_args');
    buf.writeln('');
    buf.writeln('  _arguments -C \\');
    buf.writeln('    ":command:->command" \\');
    buf.writeln('    "*::arg:->args"');
    buf.writeln('');
    buf.writeln('  case "\$state" in');
    buf.writeln('    command)');
    buf.writeln('      _describe -t commands "commands" commands');
    buf.writeln('      _describe -t options "options" global_opts');
    buf.writeln('      ;;');
    buf.writeln('    args)');
    buf.writeln('      case \$line[1] in');

    for (final cmd in tool.commands) {
      buf.writeln('        :${cmd.name})');
      buf.writeln('          local -a ${cmd.name}_opts');
      buf.writeln('          ${cmd.name}_opts=(');
      for (final opt in cmd.allOptions) {
        final desc = opt.description.replaceAll("'", "\\'");
        if (opt.abbr != null) {
          buf.writeln("            '-${opt.abbr}[$desc]'");
        }
        buf.writeln("            '--${opt.name}[$desc]'");
      }
      buf.writeln('          )');
      buf.writeln('          _describe -t options "options" ${cmd.name}_opts');
      buf.writeln('          ;;');
    }

    buf.writeln('      esac');
    buf.writeln('      ;;');
    buf.writeln('  esac');
    buf.writeln('}');
    buf.writeln('');
    buf.writeln('_$name "\$@"');

    return buf.toString();
  }

  /// Generate fish completion script.
  static String generateFish(ToolDefinition tool) {
    final buf = StringBuffer();
    final name = tool.name;

    buf.writeln('# Fish completion for $name');
    buf.writeln('# Generated by tom_build_base v2');
    buf.writeln('');

    // Disable file completion by default
    buf.writeln('complete -c $name -f');
    buf.writeln('');

    // Commands
    buf.writeln('# Commands');
    for (final cmd in tool.commands) {
      buf.writeln(
        'complete -c $name -n "__fish_use_subcommand" -a ":${cmd.name}" -d "${cmd.description}"',
      );
    }
    buf.writeln('');

    // Global options
    buf.writeln('# Global options');
    for (final opt in tool.allGlobalOptions) {
      final short = opt.abbr != null ? '-s ${opt.abbr} ' : '';
      buf.writeln(
        'complete -c $name $short-l ${opt.name} -d "${opt.description}"',
      );
    }
    buf.writeln('');

    // Command-specific options
    for (final cmd in tool.commands) {
      buf.writeln('# :${cmd.name} options');
      for (final opt in cmd.options) {
        final short = opt.abbr != null ? '-s ${opt.abbr} ' : '';
        buf.writeln(
          'complete -c $name -n "__fish_seen_subcommand_from :${cmd.name}" $short-l ${opt.name} -d "${opt.description}"',
        );
      }
      buf.writeln('');
    }

    return buf.toString();
  }

  /// Get commands string for bash completion.
  static String _getCommandsStr(ToolDefinition tool) {
    final cmds = <String>[];
    for (final cmd in tool.commands) {
      cmds.add(':${cmd.name}');
      for (final alias in cmd.aliases) {
        cmds.add(':$alias');
      }
    }
    return cmds.join(' ');
  }

  /// Get global options string for bash completion.
  static String _getGlobalOptsStr(ToolDefinition tool) {
    final opts = <String>[];
    for (final opt in tool.allGlobalOptions) {
      if (opt.abbr != null) {
        opts.add('-${opt.abbr}');
      }
      opts.add('--${opt.name}');
    }
    return opts.join(' ');
  }

  /// Get command options string for bash completion.
  static String _getCommandOptsStr(CommandDefinition cmd) {
    final opts = <String>[];
    for (final opt in cmd.allOptions) {
      if (opt.abbr != null) {
        opts.add('-${opt.abbr}');
      }
      opts.add('--${opt.name}');
    }
    return opts.join(' ');
  }
}

/// Shell type for completion scripts.
enum ShellType {
  /// Bash shell.
  bash,

  /// Zsh shell.
  zsh,

  /// Fish shell.
  fish,
}

/// Extension to generate completions.
extension ToolDefinitionCompletion on ToolDefinition {
  /// Generate completion script for the specified shell.
  String generateCompletion(ShellType shell) {
    return switch (shell) {
      ShellType.bash => CompletionGenerator.generateBash(this),
      ShellType.zsh => CompletionGenerator.generateZsh(this),
      ShellType.fish => CompletionGenerator.generateFish(this),
    };
  }

  // Note: To write completion scripts, use generateCompletion() and write with dart:io
  // Example:
  //   import 'dart:io';
  //   File(path).writeAsStringSync(tool.generateCompletion(ShellType.bash));
}
